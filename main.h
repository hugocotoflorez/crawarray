static signed char _data[] = {
	"#include <ctype.h>\x0a#include <fcntl.h>\x0a#include <stdio.h>\x0a#incl"
	"ude <unistd.h>\x0a\x0a\x0a#define BUF_SIZE (1024 * 1024)\x0a#define LIN"
	"E_SIZE (80)\x0a#define TAB_SIZE (8)\x0a\x0a#define MAX(a, b) ((a) > (b)"
	" ? (a) : (b))\x0a\x0aint\x0amain(int argc, char *argv[])\x0a{\x0a      "
	"  int fdin;\x0a        int fdout;\x0a        unsigned char buffer[BUF_S"
	"IZE];\x0a        ssize_t n;\x0a        int offset;\x0a\x0a        if (a"
	"rgc != 3) {\x0a                /* TODO: support a single arguent and ex"
	"tract out name from it */\x0a                fprintf(stderr, \"Usage: %"
	"s <In filename> <out filename>\\n\", argv[0]);\x0a                retur"
	"n 1;\x0a        }\x0a\x0a        fdin = open(argv[1], O_RDONLY);\x0a   "
	"     if (fdin < 0) {\x0a                perror(\"open\");\x0a          "
	"      return 2;\x0a        }\x0a\x0a        fdout = open(argv[2], O_WRO"
	"NLY | O_CREAT | O_APPEND, 0600);\x0a        if (fdout < 0) {\x0a       "
	"         close(fdin);\x0a                perror(\"open\");\x0a         "
	"       return 3;\x0a        }\x0a\x0a        enum STATE {\x0a          "
	"      NORMAL,\x0a                ON_STRING,\x0a        } state = NORMAL"
	";\x0a\x0a        int counter;\x0a        counter = TAB_SIZE;\x0a       "
	" /* Todo: Use const char* instead of single bytes as numbers */\x0a    "
	"    dprintf(fdout, \"static signed char _data[] = {\\n\\t\");\x0a      "
	"  while ((n = read(fdin, buffer, sizeof buffer)) > 0) {\x0a            "
	"    for (offset = 0; offset < n; offset++) {\x0a                       "
	" if (isprint(buffer[offset])) {\x0a                                if ("
	"buffer[offset] == '\"') {\x0a                                        if"
	" (state == NORMAL) {\x0a                                               "
	" counter += dprintf(fdout, \"\\\"\\\\%c\", buffer[offset]);\x0a        "
	"                                        state = ON_STRING;\x0a         "
	"                               } else if (state == ON_STRING) {\x0a    "
	"                                            counter += dprintf(fdout, \"\\\\%"
	"c\", buffer[offset]);\x0a                                        }\x0a "
	"                                       continue;\x0a                   "
	"             }\x0a\x0a                                if (buffer[offset"
	"] == '\\\\') {\x0a                                        if (state == "
	"NORMAL) {\x0a                                                counter +="
	" dprintf(fdout, \"\\\"\\\\%c\", buffer[offset]);\x0a                   "
	"                             state = ON_STRING;\x0a                    "
	"                    } else if (state == ON_STRING) {\x0a               "
	"                                 counter += dprintf(fdout, \"\\\\%c\", "
	"buffer[offset]);\x0a                                        }\x0a      "
	"                                  continue;\x0a                        "
	"        }\x0a\x0a                                if (state == NORMAL) {"
	"\x0a                                        counter += dprintf(fdout, \"\\\"%"
	"c\", buffer[offset]);\x0a                                        state "
	"= ON_STRING;\x0a                                } else if (state == ON_"
	"STRING) {\x0a                                        counter += dprintf"
	"(fdout, \"%c\", buffer[offset]);\x0a                                }\x0a"
	"                        }\x0a\x0a                        else {\x0a    "
	"                            if (state == NORMAL) {\x0a                 "
	"                       counter += dprintf(fdout, \"\\\"\\\\x%02x\", buf"
	"fer[offset]);\x0a                                        state = ON_STR"
	"ING;\x0a                                } else if (state == ON_STRING) "
	"{\x0a                                        counter += dprintf(fdout, "
	"\"\\\\x%02x\", buffer[offset]);\x0a                                }\x0a"
	"                        }\x0a\x0a                        if (counter >="
	" LINE_SIZE) {\x0a                                if (state == NORMAL)\x0a"
	"                                        dprintf(fdout, \"\\n\\t\");\x0a"
	"                                else if (state == ON_STRING) {\x0a     "
	"                                   dprintf(fdout, \"\\\"\\n\\t\");\x0a "
	"                                       state = NORMAL;\x0a             "
	"                   }\x0a                                counter = TAB_S"
	"IZE; /* TODO: now it assumes tabs are 8 width */\x0a                   "
	"     }\x0a                }\x0a        }\x0a\x0a        if (state == NO"
	"RMAL)\x0a                dprintf(fdout, \"\\n};\\n\");\x0a        else "
	"if (state == ON_STRING)\x0a                dprintf(fdout, \"\\\"\\n};\\n"
	"\");\x0a\x0a        close(fdin);\x0a        close(fdout);\x0a\x0a      "
	"  if (n < 0) {\x0a                perror(\"read\");\x0a                "
	"return 4;\x0a        }\x0a\x0a        return 0;\x0a}\x0a"
};
